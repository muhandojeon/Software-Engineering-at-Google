# Chapter 1. 소프트웨어 엔지니어링이란?

* 프로그래밍과 소프트웨어 엔지니어링의 차이
	 * 시간
	 * 규모 확장
	 * 실전에서의 트레이드오프
* 소프트웨어 엔지니어링은 흐르는 시간 위헤서 순간순간의 프로그래밍을 모두 합산한 것
* 소프트웨어 엔지니어링에서는 주기적으로 여러 선택지 사이의 트레이드오프를 평가해야 한다.
	* 규모 확장에 따른 비용 관리 등

## 1.1 시간과 변경
* 대부분의 코드는 단명한다.
* -> 오.. 내 약점이라 생각했는데 10년차 개발자라도 초기 스타트업에서만 일했으면 그럴 수 있다니 위로가 되는 문장
* 소프트웨어 프로젝트의 기대 수명과 업그레이드 중요도의 관계
	* 초기부터 업그레이드를 계획하지 않았다면, 지속하는 프로젝트로의 전환이 고통스러울 것
### 1.1.1 하이럼의 법칙
* 동작한다 vs 유지보수 가능하다 를 구분짓는 가장 중요한 요인
* 최선의 의도, 최고의 엔지니어, 꼼꼼한 코드 리뷰가 뒷받침 되더라도 공표한 계약이나 모범 사례를 완벽하게 구현했다고 단정할 수 없는 현실
* API 명세를 변경한 경우 -> 모든 변경은 누군가의 워크플로와 충돌한다.
### 1.1.2 사례: 해시 순서
* 기발한이 칭찬이면 프로그래밍
* 질책이면 소프트웨어 엔지니어링
### 1.1.3 '변하지 않기'를 목표로 하지 않는 이유
* 변경은 피할 수 없다 라는 가정이 밑바탕

## 1.2 규모 확장과 효율성
* 코드베이스의 수명이 다할 때 까지 직면하는 변화가 몰고 오는 모든 변경을 안전하게 처리할 수 있다면 그 코드베이스는 지속 가능하다.
* 인적 비용, 네트워크 확장 비용 등 다양한 비용들을 고려해도 확장 가능한가?

### 1.2.1 확장하기 어려운 정책들
* 조직이 10배로 커지면 이 작업도 10배로 많아지는가?
* 엔지니어가 해야 할 일의 양이 조직이 커질 수록 늘어나는가?
* 코드베이스가 커질수록 작업량도 늘어나는가?
* 이 중 하나에 해당할 경우 작업을 자동화하거나 최적화할 수단이 있는가?

* 아니오 라면 확장성에 문제가 있는 것

### 1.2.2 확장 가능한 정책들
* 비욘세 규칙
	* 니가 좋아했다면 CI test를 준비해뒀어야지
### 1.2.3 사례: 컴파일러 업그레이드
* 코드베이스의 유연성에 영향을 주는 여러 요인
	* 전문성
	* 안정성
	* 순응
	* 익숙함
	* 정책
### 1.2.4 원점 회귀 (왼쪽으로 옮기기)
* 문제 발견 시점을 당길수록 수정 비용이 줄어든다.
* 코드 커밋 전에 정적 검사나 코드 리뷰로 찾아낸 버그는 프로덕션 이후에 발견한 버그보다 훨씬 싸게 고칠 수 있다.
## 1.3 트레이드오프와 비용
* 비용 종류
	* 금융 비용 / 리소스 비용 / 인적 비용 / 거래 비용 / 기회 비용 / 사회적 비용 
* 엔지니어링 조직의 선택을 결정짓는 요인
	* 반드시 해야 하는 일
	* 근거에 기반하여 당시 내릴 수 있는 최선의 선택
		* 근거 자료의 가중치
			* 측정, 추정 가능한 경우
			* 측정하기 어렵거나 측정 방법을 모르는 정량적 데이터는 리더십, 선례를 바탕으로 정량화
## 1.4 소프트웨어 엔지니어링 vs 프로그래밍
* 프로그래밍은 코드를 생산하는 즉각적 행위
* 소프트웨어 엔지니어링은 활용 가치가 남아 있는 한 오랫동안 코드를 유용하게 관리하고 팀 간 협업을 가능케 하는 정책, 관례, 도구 모두를 아우르는 종합적인 개념



-> 이 책은 뭐랄까.. 이론에만 국한된 베스트 프랙티스가 아닌 실무에서 겪을 수 밖에 없는 문제들을 바탕으로 최선의 방향을 찾아 타협한 내용을 담은 느낌이라 더 공감이 많이 됨