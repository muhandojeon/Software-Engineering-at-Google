# 소프트웨어 엔지니어링이란?

프로그래밍은 그저 소프트웨어 개발을 위한 수단.
'이 코드가 언제까지 동작하고 유지보수될 것인지'와 같은 시간 개념이 프로그래밍에 더해졌을 때 소프트웨어 엔지니어링이라고 할 수 있다.

## 시간과 변경

- 하이럼의 법칙: API 사용자가 충분히 많다면, 명세는 중요치 않다. 사용자들은 해당 API를 통해 할 수 있는 모든 걸 이용하게 된다.

API의 노출 시간이 길어지고 사용자가 늘어나면 가장 무해할 듯한 변경도 일부 사용자의 소프트웨어를 망가뜨릴 수 있다.
사용자가 명세에 없는 기능을 찾아 활용할 수도 있기 때문이다.
따라서 변경이 얼마나 유용할지 분석할 때는 이러한 충돌을 조사하는 것도 고려해야 한다.

## 규모 확장과 효율성

- 원점 회귀(Shift Left): 개발 과정에서 문제를 일찍 발견할수록 비용이 적게 든다. 문제 발견 시점을 왼쪽으로 이동시킬수록 수정 비용이 줄어든다.

> 개발하는 건 재밌으니까 설계를 빠르게 넘기고 구현으로 넘어가곤 했는데요, 이러면 확실히 나중에 요구사항들을 수정할 일이 생겼을 때 많이 고통 받긴 했네요.

## 트레이드오프와 비용

조직의 건실성에는 은행 잔고뿐 아니라 구성원들이 스스로의 가치를 느끼고 생산적인 일을 하고 있다고 생각하는지까지 포함된다.
엔지니어들이 행복을 느끼게 만들고 일에 집중하고 참여할 수 있게 해주면 효율이 높아진다.

> 짧지만 커리어 내내 거의 스스로 재미를 찾기 위해 많이 노력했는데요, 제 성향과 수준을 고려해 누군가 과제를 계속해서 던져준다면 어떤 느낌일지 궁금합니다.
> 예전에 항해 플러스를 할 때 라인에 다니는 멘토님이 말하기를, 본인은 커리어 초반에 사수가 자신의 수준보다 조금 더 어려운 과제를 계속해서 던져줬다고 하더라구요. 부러웠습니다.

구글의 문화는 데이터 주도적이다. 데이터가 없을 때조차 근거, **선례**, 논증을 거쳐 결정을 내리곤 합니다.

> 데이터가 없더라도 선례를 보여주면 설득력이 높아지곤 했었네요. 더 잘 써먹어야겠습니다.

<br />
<br />

---

<br />
<br />

- 결국 1장은 'It depends...'가 많이 생각나는 장이었네요.
- 그래도 1장에서 얻어가는 건 결정 프레임워크였습니다.
  - 데이터가 있다면 이를 기반으로 근거 -> 선례 -> 논증
  - 없더라도 근거 -> 선례 -> 논증
  - 모두가 합의를 못하더라도 결정권자가 결정을 내린다.
