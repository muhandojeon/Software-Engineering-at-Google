## 들어가며

- 테스트 대역(test double): 실제 구현 대신 사용할 수 있는 개체와 함수

## 테스트 대역이 소프트웨어 개발에 미치는 영향

- 테스트 용이성(testability): 코드베이스가 테스트하기 쉽도록 설계될 것
- 적용 가능성(applicability): 안 써야 할 곳에 잘못 쓰면 나쁜 테스트가 됨
- 충실성(fidelity): 테스트 대역이 실제 구현의 행위와 얼마나 유사한가

## 기본 개념

### 모의 객체 프레임워크

- 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리
- 모의 객체(mock): 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역
- 과용하면 코드베이스를 유지보수하기 어렵게 되는 부작용

## 테스트 대역 활용 기법

### 속이기(가짜 객체)

- 가짜 객체(fake object): 제품 코드로는 부적합하나 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역(ex. 인메모리 데이터베이스)
- 가짜 객체를 만들 때 실제 객체의 현재와 미래까지 고려해야 하므로 난이도가 있다.

### 뭉개기(스텁)

- 스텁(stub): 원래는 없던 행위를 부여하는 과정
- 대상 함수가 반환할 값을 지정한다며, '반환값을 뭉갠다'고 표현
- 보통 모의 객체 프레임워크를 이용해 수행
- 빠르고 쉽게 적용할 수 있는 기술이지만 한계가 있음

### 상호작용 테스트

- 상호작용 테스트(interaction test): 대상 함수를 실제로 호출하지 않고도 그 함수가 '어떻게' 호출되는지를 검증하는 기법
- 주로 모의 객체 프레임워크 사용
- 과용하면 테스트들이 깨지기 쉽게 변하니 사용하지 않는 걸 권장

## 실제 구현

- 고전적 테스트(classical test): 실제 구현을 선호하는 테스트 방식
- 모의 객체 중심주의 테스트(mockist test): 모의 객체 프레임워크를 선호하는 테스트 방식
- 구글은 모의 객체 중심주의는 확장하기 어렵다고 결론 지음

### 격리보다 현실성을 우선하자

- 구글은 현실적인 테스트를 선호
- 대상 시스템이 올바르게 동작한다는 확신을 높여준다.
- 좋은 테스트는 구현이 어떻게 구성되었느냐의 관점이 아니라 검사할 API를 중심으로 작성

### 실제 구현을 사용할지 결정하기

- 빠르고 결정적이고 의존성 구조가 간단하다면 실제 구현을 사용하는 게 좋다.
- 예컨데 값 객체(value object)라면 실제 구현을 사용
- trade-off가 있으므로 아래 고려 사항을 염두에 두고 판단

#### 실행 시간

- 수행 시간이 오래 걸릴 때는 테스트 대역이 유용
- 실제 구현은 구현과 참조 코드도 모두 빌드해야 하므로 오래 걸릴 수 있다.

#### 결정성

- 결정적: 같은 버전의 시스템을 대상으로 실행하면 언제나 똑같은 결과를 내어주는 테스트
- 테스트에서 비결정성은 불규칙한 결과로 이어진다.
- 실제 구현은 테스트 대역보다 훨씬 복잡하기에 비결정적일 여지가 더 많다.
- 테스트가 통제할 수 없는 외부 서비스에 의존하는 코드는 비결정성의 주범으로 꼽힌다.

#### 의존성 생성

- 실제 구현을 이용하려면 의존 대상들도 모두 생성해야 한다.
- 테스트 대역은 다른 객체를 별로 사용하지 않으므로 생성하기 훨씬 쉽다.
- 제품 코드가 팩터리 메서드나 자동 의존성 주입을 지원한다면 테스트에서도 똑같이 이용하는 게 좋다.

## 속이기(가짜 객체)

- 실제 구현을 이용할 수 없을 때에 최선인 경우가 많다.
- 실제 구현과 비슷하게 동작
- 대상 시스템은 자신이 이용하는 것이 실제 구현인지 가짜 객체인지 구분할 수 없어야 한다.

### 가짜 객체가 중요한 이유

- 빠르게 결과 확인 가능
- 실제 객체를 사용할 때의 단점을 제거

### 가짜 객체를 작성해야 할 때

- 가짜 객체의 작성과 갱신 모두 노력과 도메인 지식을 수반한다.
- 테스트에서 진짜 객체를 사용하지 못하게 만드는 근본 원인을 찾아라.
- 그런 다음 해당 코드만 가짜 객체로 만들라.

### 가짜 객체의 충실성

- 충실성: 가짜 객체가 실제 구현의 행위를 얼마나 비슷하게 흉내 내는지의 척도
- 실제 구현과 다르게 동작한다면 가짜 객체를 이용하는 테스트들은 쓸모가 없다.
- 가짜 객체는 100% 충실하긴 어렵더라도 실제 구현의 API 명세에 가능한 충실해야 한다.

### 가짜 객체도 테스트해야

- 가짜 객체에도 '고유한' 테스트가 딸려 있어야 한다.
- 실제 구현과 가짜 객체 둘 다를 대상으로 하는 공개 인터페이스 검증 테스트를 작성한다. (계약(명세) 테스트)

## 뭉개기(스텁)

원래는 없는 행위를 테스트가 함수에 덧씌우는 방법

### 스텁 과용의 위험성

- 적용하기 쉽지만, 과용하면 테스트를 유지보수할 일이 늘어난다.

#### 불명확해진다

- 대상 함수에 행위를 덧씌우는 코드를 추가 작성하는데, 읽는 이의 눈을 어지럽힌다.
- 테스트의 의도를 파악하기 어렵게 한다.
- **특정 함수를 스텁으로 뭉갠 이유를 이해하기 위해 실제 시스템의 코드를 살펴보게 된다**면 적합하지 않다는 신호

#### 깨지기 쉬워진다

- 내부 구현 방식이 테스트에 드러난다.
- 제품의 내부가 다르게 구현되면 테스트 코드도 함께 수정해야 한다.
- 좋은 테스트는 사용자에게 영향을 주는 공개 API가 아닌 한, 내부의 변화가 영향을 주지 않아야 한다.

#### 테스트 효과가 감소한다

- 해당 함수가 실제 구현과 똑같이 동작하는지 보장할 방법이 사라진다.
- 상태를 저장할 방법이 사라져서 대상 시스템의 특성 일부를 테스트하기 어렵다.

> 스텁은 실제 데이터의 삽입을 우회하는 좋은 예시로서만 알고 있었는데, 유지보수를 안 좋게 하는 면이 있었네요.

### 스텁이 적합한 경우

- 특정 함수가 특정 값을 반환하도록 하여 대상 시스템을 원하는 상태로 변경하려 할 때 제격
- 적은 수의 함수만 스텁으로 대체한다. 스텁된 함수가 많을수록 테스트의 의도는 희미해진다.

## 상호작용 테스트하기

- 대상 함수의 구현을 '호출하지 않으면서' 그 함수가 어떻게 호출되는지를 검증하는 기법

### 상호작용 테스트보다 상태 테스트를 우선하자

- 상태 테스트(state test): 대상 시스템을 호출하여 올바른 값을 반환하는지, 혹은 대상 시스템의 상태가 올바르게 변경되었는지를 검증하는 테스트
- 상호작용 테스트의 가장 큰 문제: 호출되었는지만 확인하고 올바르게 작동하는지는 말해주지 못한다는 점
- 상호작용 테스트의 두 번째 문제: 대상 시스템의 상세 구현 방식을 활용한다.
- 구현 방식이 바뀌면 테스트가 깨질 수 있다.

### 상호작용 테스트가 적합한 경우

- 실제 구현이나 가짜 객체를 이용할 수 없을 때
- 함수 호출 횟수나 호출 순서가 달라지면 기대와 다르게 동작하는 경우

### 상호작용 테스트 모범 사례

- 상태 변경 함수일 경우에만 상호작용 테스트를 우선 고려하자
  - 상태를 변경하는 상호작용이라면 '코드가 다른 어딘가의 상태를 변경한다'는 유의미한 일을 한다는 뜻
- 너무 상세한 테스트는 피하자
  - 어떤 함수들이 어떤 인자를 받아 호출되는지를 너무 세세하게 검증하지 말라.
  - 테스트는 명확하고 간결해야 한다.
