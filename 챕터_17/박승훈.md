## Code Search

- 구글이 이용하는 코드 브라우징 및 검색 도구
- 단순 코드 검색에서 브라우징으로 초점 이동
- 최종 원칙: "클릭 한 번으로 다음 (예상) 질문에 답해주기"
- 대규모 코드를 읽고, 이해하고, 탐색하는 데 최적화

## Code Search UI

- 검색: 파일에서 찾기 + 랭킹과 코드 강조, 범위 인식, 주석 및 문자열 인식
- 결과에 랭킹을 매겨 보여주고 표현력 좋은 질의어를 제공
  - 랭킹: 검색 결과의 수가 많은 일반적인 경우를 도움
  - 표현력 좋은 질의어: 결과의 개수가 줄어들 수 있도록 조건을 매우 구체적으로 정의 가능

## 구글 개발자 Code Search를 이용하는 방법

- 전통적인 파일 브라우징에 사용됨. "코드베이스의 이 부분이 무슨 일을 하는가?"의 질문에 답
- 다른 사람들이 어떻게 썼는지를 보는 용도
- 코드가 '무엇을' 하는가에 연관된 쓰임 확인
- 코드가 '왜' 기대와 다르게 동작하는지 질의
- 특정 코드 조각을 누가 언제 추가했는지 찾는 용도(like git blame)
- 라인을 추가한 코드 리뷰로 점프 가능

> Code Search를 사용하는 것도 좋지만, 어떤 용도로 사용하거나 동작들을 수집하고 통계를 낸 것도 신기합니다. 모든 동작에 추적과 기록이 되는 체계라니요.

## 독립된 웹 도구로 만든 이유

### 대규모 코드베이스 지원

- 구글의 코드베이스가 너무 거대해서 코드베이스 전체를 로컬로 복사하는 게 불가능
- local 검색과 참조 index 생성으로 IDE 구동 시간이 느려진다. 개발자 생산성을 떨어뜨린다.
- 인덱스를 중앙에서 생성하면 한 번만 생성헤도 모두에게 혜택이 돌아온다.

> [DeepWiki](https://deepwiki.com/)라는 사이트가 생각 나네요. 목표 repository를 분석하여 indexing하고 생성형 AI에게 질문도 할 수 있게 만들어 두었는데요, 한 번만 분석이 되면 모든 사람들이 코드를 쉽게 파악할 수 있다는 점에서 비슷하다고 생각이 들어요.

### 설정 없이 모든 코드 보기

- 웹 UI에서 아무 설정 없이 코드베이스를 이용할 수 있다.
- 어디에서 등장하는 코드든 상관 없이 매우 쉽고 빠르게 찾아 검토할 수 있다.

> 그 커다란 코드베이스를 설정 없이 조회하고 수정할 수 있다는 것이 엄청나게 매력적이라고 생각이 드네요.

### 기능 특화

- IDE가 아니기 때문에 '편집'이 아닌 코드 '탐색'과 '이해'에 사용자 경험을 최적화할 수 있다.
- 편집기용 텍스트 커서가 필요 없으므로 심볼을 클릭하면 더 의미 있는 기능을 수행할 수 있다.

### API 제공

- 검색, 상호참조, 구문 강조 기능을 API로 제공한다.
- 다른 도구 개발자가 가져다 쓸 수 있다.

## 규모가 설계에 미치는 영향

- 규모가 너무 크면 코드 검색과 브라우징이 어려워진다.
- 코드 검색 확장에 가장 큰 걸림돌은 전체 코드의 크기이다.
- 중앙집중형 검색 솔루션은 이용자 수와 코드량이 늘면 함께 비대해진다.

### 검색 쿼리 지연시간

- 짧은 지연시간은 공짜로 주어지지 않는다.
- 지연시간 줄이기에 투자할지 결정하려면 전체적인 엔지니어링 시간을 얼마나 줄일 수 있는지 비교할 수 있어야 한다.
- 지연시간 증가와 생산성 손실은 지수적으로 늘어난다. 자주 쓰이는 기능은 백엔드 리소스를 들여 지연시간을 최소화한다.

### 인덱싱 지연시간

- 생성한 코드, 제거한 코드 등 작업한 코드들은 바로 반영되어 최신 버전이기를 기대한다.
- 희소 n-그램, 토근 기반 n-그램, 역 인덱스, 인코딩 등 다양한 기술들을 도입했다.
- 로컬 작업 공간용으로 무차별 검색 수행하는 머신을 여러 대 두었다.

### 랭킹

- 파일의 여러 특성(signal)을 점수로 환산하고 좋은 결과를 먼저 노출시킨다.
- 시그널은 문서(파일)에만 의존적인 (쿼리 독립적) 시그널, 검색 쿼리와 쿼리를 어떻게 문서에 매치시킬지에 의존하는 (쿼리 의존적) 시그널로 구분된다.

#### 쿼리 독립적 시그널

- 파일명 길이, 프로그래밍 언어, 파일 조회수, 참조량 등
- 오프라인에서도 계산할 수 있어 계산량이 많아도 크게 문제가 되지 않는다.

#### 쿼리 의존적 시그널

- 일치 항목이 함수 정의인지, 문자열 리터럴인지 등
- 뭐리마다 계산하는 방식이라서 계산량이 적어야 한다.
- 인덱스로부터 빠르게 얻을 수 있는 쿼리와 정보만 이용해야 한다.

#### 검출(검색)

- 문서에 점수를 매기기 전에 검색 쿼리와 일치할 가능성이 있는 후보 검색
- 주요 과제는 관련이 적은 수많은 파일 중에서 관련도 높은 소수의 파일을 찾는 일
- 보충 검출(검색)으로 해결할 수 있다.

#### 결과 다양성

- 검색은 결과를 다양하게 보여줄 수 있어야 한다. (분류별로 최상의 결과)
- 해결 과제는 분류의 가짓수가 너무 많을 수 있다는 점

> 코드 검색도 구글 수준의 코드베이스가 되다보니 엄청나게 신경을 쓰고 설계를 한다는 사실이 흥미로웠습니다.

## 구글이 선택한 트레이드오프

### 완벽성: 헤드 리포지토리

불필요한 컨텐츠를 인덱싱에서 제외한다.

- 사람이 읽을 수 없는 텍스트가 아닌 파일들
- 난독화된 javascript 파일들
- 다만, 제외된 파일로 인해 피드백에 구멍이 생겨 혼란과 생산성 손실, 신뢰를 잃을 수 있다.
- 구글은 자원을 절약하지 않고 인덱싱을 많이 하기로 결정
- 도구가 생성한 파일들은 복잡도와 혼란이 가중되고 지연시간을 늘려 인덱싱을 하지 않기로 결정

### 완벽성: 전부 vs 가장 관련성 높은 결과만

- 웹 검색에서는 속도를 위해 완벽성을 희생한다.
- 무수한 결과를 '전부' 제공하려면 자원을 많이 쓰지만 도구를 개발하거나 개발자 결과를 신뢰하게 하는 데 필요한 기능
- 두 마리 토끼를 모두 잡기 위해 코드베이스 전체를 조각으로 나누고 양방 분석

> 구글, 특히 Code Search는 개발자의 신뢰를 잃지 않기 위해 노력하는 모습들이 돋보였습니다. 구글이 그동안 피를 흘리며 얻는 교훈이겠죠.

### 완벽성: 헤드 vs 브랜치 vs 모든 변경 이력 vs 작업 공간

- 인덱싱에 '시간'이라는 차원이 들어가면 복잡도, 자원, 비용이 급상승한다.
- 과거 기록에 대한 인덱싱을 유지하는 구조는 아직까지 없다.
- 버전을 넘나들 수는 없지만 변경, 삭제 기록을 인덱싱해 예전 기록을 참조할 수 있다. (Code Search 예시)

### 표현력: 토큰 vs 부분 문자열 vs 정규 표현식

#### 정규 표현식

- 기능 지원의 범위에 따라 레포지토리 규모의 영향력이 크게 달라진다.
- Code Search는 정규 표현식 검색을 지원한다.
- 정규표현식 검색을 효율적으로 지원할 수 있는 인덱스를 만드는 건 어렵다.

#### 토큰 기반 인덱스

- 소스 코드 일부를 저장하면 되고, 표준 검색 엔진에서 잘 지원하기에 확장성이 좋다.
- 활용성이 많이 줄어든다. (function()과 function(x)를 다르게 인식)
- 코드 식별자가 잘못 정의될 수 있다.
- 대소문자를 구분하지 않으며 단어를 뭉개기도 한다. 정확도가 희생된다.

#### 전체 부분 문자열

- 문자들의 순서에 상관없이 검색 가능
- 트라이그램 기반 인덱스 사용
- 재현 정확도가 다른 부분 문자열 인덱스 기법보다 낮다.

> 검색, 랭킹 등 구글의 거대한 코드 베이스를 조회할 때 감수해야 하는 기술적 배경이 상당히 깊다는 걸 알았습니다. 블로그를 개발할 때 문구가 제목에 포함되었는지, 카테고리, 태그에 포함되었는지 내용에 있는지 등으로 우선순위를 정해 랭킹을 계산하기도 했는데 캐싱과 인덱싱을 고려해 훨씬 복잡한 기술을 염두에 두고 있다는 것에 '과연 구글이구나' 싶습니다. 구글 검색할 때 몇 천만 건의 검색 결과가 0.001초만에 나왔다고 표시되는 게 너무 신기했는데 내부적으로도 검색 엔진 이름값을 하는구나 느낍니다.
