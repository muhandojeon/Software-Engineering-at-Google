# 챕터 21 의존성 관리

의존성 관리란 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일

'다른 조건이 모두 같다면 의존성 관리 문제보다는 소스 관리 문제를 택하라' => 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴함

의존성 관리할 때 극복해야 하는 문제, 일반적인 혹은 새로운 해법, 한계에 대해 알아보자~~~

## 의존성 관리가 어려운 이유

### 요구사항 충돌과 다이아몬드 의존성

버전 비호환 문제의 대표적인 예는 다이아몬드 의존성 문제이다

발생 조건은 의존성 계층이 최소 세 개가 필요하고, 의존성 그래프에 특정 조건을 요구하는 노드가 추가 되어 일어나는 문제임

<img width="282" height="149" alt="스크린샷 2025-08-10 오후 4 13 24" src="https://github.com/user-attachments/assets/23dcadbb-7546-4004-8eae-1376cae66c52" />

liba는 신버전 libbase를 쓰고 libb는 구버전을 쓴다면 libuser에 두 버전 모두를 포함시킬 보편적인 방법은 없다

그리고 언어마다 다이아몬드 의존성 문제가 주는 충격은 다르다

## 의존성 임포트 하기

프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다

우리 요구사항을 만족하는 외부 소프트웨어가 있다면 이용하는게 좋다!

## 호환성 약속

개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다! 

지속적인 유지보수 비용까지 감안해야 된다~~ 업그레이드할 계획 없던 의존성이라 해도 보안 취약점 발견되면 업데이트 해야되니까~~

다음 요인들을 고려하면 의존성의 유지보수 비용을 조금 더 정확하게 계산할 수 있다고 한다

- 호환성이 얼마나 잘 지켜지나요?
- 진화가 얼마나 빠르게(크게) 이루어지나요?
- 변경 처리 방법은 무엇일까요?
- 각 버전의 지원 기간은 어떻게 되나요?

### 임포트시 고려사항

'프로그래밍' 프로젝트라면 의존성 임포트는 거의 공짜에 가까움. 의존성이 하위 호환을 약속하지 않더라도 우리가 의존성을 업그레이드 하지 않는 이상 아무 문제없음

하지만 '소프트웨어 엔지니어링'으로 발을 옮기는 순간 똑같은 의존성들이 미묘하게 더 비싸짐

의존성을 임포트하기 전에 몇가지 질문들을 스스로에게 던져보자

- 여러분이 실행해볼 수 있는 테스트가 딸려 있는 프로젝트인가요?
- 테스트는 모두 통과하나요?
- 의존성 제공자는 누구인가요? e.g npm
- 앞으로 어떤 분야나 용도를 지원해나갈 것인지 자세히 설명하고 있나요?
- 얼마나 인기 있는 프로젝트인가요?
- 언제까지 이용할 건가요?
- 파괴적인 변경이 얼마나 빈번하게 행해지고 있나요?

소속된 조직 관점에서의 질문도 고려해야 된다

- 조직에서 같은 기능을 새로 구현하려면 얼마나 복잡한가요?
- 그 의존성을 최신 상태로 유지하면 어떤 이점이 있나요?
- 업그레이드는 누가 할 건가요?
- 업그레이드 하는 난이도는 어느 정도일 거라 예상하나요?

### 의존성 임포트 하기 @구글

구글 프로젝트들이 이용하는 의존성들의 압도적 다수를 구글이 직접 개발했음 ㄷ ㄷ 그래서 진정한 의존성 관리보다는 설계상 소스 코드 버전 관리에 해당함

오픈소스 생태계나 상용 파트너사로부터 임포트하는 의존성들은 모노레포의 별도 디렉터리에 추가하고, 'third_party'라는 디렉터리에 넣는다고 함

이때, 모노레포 구조다보니까 다른 팀원이 의존성을 추가하기 시작함. third_party에 추가된 특정 버전을 하이럼의 법칙이 점점 더 강하게 옥죌 수 있음 ㅋㅋ (나중에 다른 버전으로 마이그레이션 어려움)

어느날 해당 버전에 취약점이 발견되어 반드시 업그레이드해야 된다는 소식이 와서 업그레이드 했더니 다른 팀의 빌드가 다 실패해버리고 맒

이런 흔한 시나리오에 대해 third_party 정책도 말끔한 대응책이 되어주지 못하다보니, 우리는 소유권 관리를 더 체계적으로 해야 되고, 업데이트가 더 정기적으로 이루어지게 만들어야 됨

## 이론상의 의존성 관리

그래서 안정적인 의존성 관리 체계를 갖추기 위해선 시간과 규모 모든 면에서 유연해야 된다~

애초에 의존성 그래프의 어느 노드라도 영원히 변치 않으리라 가정해서는 안되고 기대도 금물이다

조직 사이의 조율이나 가시성 제한 없이, 합리적인 컴퓨팅 자원만 소모해서 가능하다면 '훌륭한' 해법이다!

### 변경 불가(정적 의존성 모델)

애초에 변경 자체를 허용하지 않는 방법.

멀리 보면 지속 가능하지 않아보이는데 사실 모든 조직이 처음에 이렇게 시작함 ㅇㅈ?

어차피 의존성을 물 흐르듯 업데이트해야 할 필요가 있을지를 알고 시작하는 경우도 흔치 않으니까 ㅋㅋ

걍 몇 해 정도는 의존성들이 완벽하게 안정적일거라고 가정하고 진행하는게 합리적일 것임

단점은 프로젝트가 오래 살아남을수록 가정이 틀릴 가능성 점점 커지고 언제까지 유효할지 정확히 모름.(지표가 없음)

나중에 서로 얽혀있는 의존성을 풀어야 하는 날이 오고, 하나만 업데이트하려다가 전체를 업데이트 해야하는 상황으로 치달을 수도 있다..~


### 유의적 버전

오늘날 의존성 네트워크 관리하는 가장 대표적인 방법임

- 메이저: API가 변경되어 의존성을 이용하던 기존 코드를 깨뜨릴 수 있음
- 마이너: 순수하게 기능 추가만 있음（기존 코드를 깨뜨리지 않음）
- 패치 : API에 영향을 주지 않는 내부 구현 개선과 버그 수정

### 하나로 묶어 배포하기

앱 구동에 필요한 의존성들을 모두 찾아서 앱과 함께 배포하는 방법 e.g 리눅스 배포판

전문 배포자가 상호 호환되는 버전들을 찾고 패치하고 검증하는 일을 수행함 ㄷ ㄷ ㄷ

### 헤드에서 지내기

소스 관리 정책인 트렁크 기반 개발을 업스트림 의존성 관리 영역까지 확장한 것이라고 보면 됨

헤드에서 지내기는 의존성 관리에서 시간과 선택이라는 요소를 제거하려는 시도이다

모든 컴포넌트가 항상 최신버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경은 절대 허용하지 않는 방법 ㄷ ㄷ

헤드에서 지내기 모델은 더이상 SemVer에게 '이 버전은 안전할까?'라고 묻지 않음. 대신에 테스트와 CI를 이용해서 모든 사용자들에게 안전한 지를 실험을 통해 확인함

그래서 헤드에서 지내기는 다음과 같은 상황을 가정함

- 단위테스트와 CI가 갖춰져 있음
- API 제공자 다운스트림 의존성들이 깨지는지를 확인할 수 있음
- API 소비자가 테스트들이 계속 통과되고 지원 가능한 방식으로 의존성을 이용 중임

## 유의적 버전의 한계

헤드에서 지내기가 확장성이 좋은지는 입증 더 필요함. 그래서 현시점까지 업계 표준 의존성 관리는 유의적 버전임

1.1.4 => 1.2.0 으로 버전업에 의미가 API 추가와 버그 수정만 포함됐다는 소리여서 업그레이드는 안전하고 쉬울것인가??

> next.js v13.x.x 특정 버전 구간에서 동작하는 기능이 상이하고 버그가 많아서 의존성 관리가 매우 어려웠던 기억이 있음

현실에서 설계 의도와 다르게 사용중인 사용자 때문에(하이럼의 법칙) 빌드가 깨질 수 있고 '단순한' API 추가 행위가 라이브러리가 엉뚱하게 동작하게 만드는 등 경우의 수가 많음

API만 고려해서는 호환성에 대해 아무것도 '증명' 못함 => 호환성에 대해 정확히 무엇을 요구하는지를 아는게 중요

### 최소 버전 선택

미래를 100% 확신할 수 없다면 가능한 한 차이가 작게 버전업 하는게 가장 안전함

한시간 치 작업을 커밋하는 게 일 년 치 작업을한꺼번에 커밋하는 것 보다 안전하듯, 의존성 업데이트도 작게 해주는게 안전 하다~

e.g liba 1.0이 libbase >= 1.7을 요구한다? 1.9가 존재하더라도 1.7로 ㄱ ㄱ


## 마치며

현재 의존성 네트워크를 관리하는 업계 표준 방법은 유의적 버전(SemVer)인데, 

SemVer는 변경에 수반되는 위험을 요약해 제공하다 보니 때로는 중요한 내용을 빠뜨린다는 한계가 있다

그럼에도 SemVer는 작은 규모에서 훌륭히 제 역할을 해내고, 최소 버전 선택 방식까지 수용한다면 더욱 효과적이다

하지만 의존성 네트워크가 커지면 하이럼의 법칙과 정보를 누락한다는 SemVer 자체의 문제 떄문에 버전 선택하기가 점점 어려워진다~

> 이정도까지 대규모 코드베이스에서 의존성이 엮여 있었던 적이 없어서 공감하기 어렵긴 하네요,,~

메인테이너는 결국 추정한 호환성을 버리고 실제로 확인할 수 있는 증거를 적극 활용한다면 이상적인 세계에 한걸음 다가 설 수 있다

사용자들이 하던 호환성 테스트를 API 제공자가 더 많이 떠안고 앞으로 어떤 유형의 변경이 이루어질 수 있는지 명확히 알려준다면! 거대한 의존성 네트워크도 더 충실하게 관리될 수 있을 것이다~

> 이게 가장 어려워 보이네요~~ 메인테이너들이 버전업에 대한 책임감과 임무가 결국 부담감으로 다가올 것 같은 느낌이여서..
