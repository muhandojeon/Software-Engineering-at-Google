# CHAPTER 21 의존성 관리

의존성 관리란 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일

## 21.1 의존성 관리가 어려운 이유

의존성 하나를 관리하는 방법이 중요한 게 아니다.  
**수많은 의존성들로 구성된 네트워크와 그 네트워크에 일어날 변화**까지 고려해 관리하는 방법을 강구해야 한다.  

### 요구사항 충돌과 디아이몬드 의존성

버전 비호환 문제의 대표적인 예는 다이아몬드 의존성  
요구사항 충돌 문제를 쉽게 해결하는 유일한 방법은 모두와 호환되는 더 상위 혹은 하위 버전의 라이브러리를 찾는 것뿐  
이게 불가능하다면 문제가 되는 의존성을 로컬에서 따로 패치해야 한다.

## 21.2 의존성 임포트하기

처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명 더 낫다.  
요구사항을 만족하는 외부 소프트웨어(의존성)가 있다면 이용하는 게 좋다.  
> 전 이 부분에 완전 동의합니다

### 호환성 약속

개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다.  
지속적인 유지보수 비용까지 고려해야 한다.
```
- 호환성이 얼마나 잘 지켜지나요?
- 진화가 얼마나 빠르게(크게) 이루어지나요?
- 변경 처리 방법은 무엇일까요?
- 각 버전의 지원 기간은 어떻게 되나요?
```

### 임포트 시 고려사항

의존성 자체에 대한 질문
```
- 여러분이 실행해볼 수 있는 테스트가 딸려 있는 프로젝트인가요?
- 테스트는 모두 통과하나요?
- 의존성 제공자는 누구인가요? 유명하다고 다 좋은 것은 아니지만 반드시 고려해보는 게 좋습니다.
- 지향하는 호환성 정책은 어떠한가요?
- 앞으로 어떤 분야나 용도를 지원해나갈 것인지 자세히 설명하고 있나요?
- 얼마나 인기 있는 프로젝트인가요? (npmtrends, bundlephobia)
- 언제까지 이용할 건가요?
- 파괴적인 변경이 얼마나 빈번하게 행해지고 있나요?
```

소속된 조직 관점에서의 질문
```
- 지금 속한 회사에서 같은 기능을 새로 구현하려면 얼마나 복잡한가요?
- 그 의존성을 최신 상태로 유지하면 어떤 이점이 있나요?
- 업그레이드는 누가 할 건가요?
- 업그레이드하는 난이도는 어느 정도일 거라 예상하나요?
```

## 21.3 (이론상의) 의존성 관리

의존성 관리 해법 4가지

### 1. 변경 불가(정적 의존성 모델)

버그 수정 외의 변경 자체를 허용하지 않는 모델  
대부분의 신생 조직에게는 적합한 모델일 수 있다.  
하지만 프로젝트가 오래 살아남을수록 가정이 틀릴 가능성이 커지며 언제까지 유효할지 알 수 있는 지표가 없다.  
이 모델은 버전이 두 개 이상 공존할 일이 없으니 버전 선택이라고 할 것도 없다.

### 2. 유의적 버전(SemVer)

오늘날 의존성 네트워크를 관리하는 가장 대표적인 방법이다.  
ex. 2.4.27  
- major : API가 변경되어 기존 코드를 깨뜨릴 수 있음
- minor : 순수하게 기능 추가만 있음
- patch : API에 영향을 주지 않는 내부 구현 개선과 버그 수정

요구사항 표현법을 정형화하면 의존성 네트워크를 소프트웨어 컴포넌트(노드)와 그 사이의 요구사항(엣지)의 집합으로 표현할 수 있다.  
대부분의 패키지 관리 생태계는 SemVer용 SAT 솔버로 관리되는 그래프를 기초로 구동된다.  
모든 버전 요구사항을 충족하는 의존성 버전을 찾는 행위를 버전 선택이라고 한다.  
만족스러운 버전 조합이 네트워크에 존재하지 않는 상황을 의존성 지옥이라고 한다.

### 3. 하나로 묶어 배포하기

애플리케이션 구동에 필요한 의존성들을 모두 찾아서 애플리케이션과 함께 배포하는 방법  
함께 묶어 배포할 버전을 찾고, 의존성 트리에서 문제가 없는지 확인하고, 문제를 해결하는 일은 배포자가 담당  
외부 사용자 입장에서는 특정 배포판 하나에만 의존하면 되니 매우 편리하다.  

이러이러한 버전의 총 72개 라이브러리에 의존한다.  
-> 레드햇 버전 N에 의존한다. or NPM 그래프에서 N 시각 때의 라이브러리들에 의존한다.  

### 4. 헤드에서 지내기

구글에서 추진하는 모델  
소스 관리 정책인 트렁크 기반 개발을 업스트림 의존성까지 적용한 모델  
의존성 관리에서 시간과 선택이라는 요소를 제거하려는 시도  
모든 컴포넌트가 항상 최신 버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경은 절대 허용하지 않음  

아래 상황을 가정함
```
- 단위 테스트와 CI가 갖춰져 있다.
- API 제공자 다운스트림 의존성들이 깨지는지 확인할 수 있다.
- API 소비자가 테스트들이 계속 통과되고 지원 가능한 방식으로 이용 중이다.
```

이 방식에서는 '모든 것의 가장 최근 안정 버전'으로 귀결된다.

## 21.4 유의적 버전의 한계

헤드에서 지내기는 확장성이 좋은지까지는 입증이 더 필요하다.  
현시점에서 업계 표준 의존성 관리는 유의적 버전(SemVer)이다.  
SemVer SAT 솔버가 문제없이 작동할 것이라고 알려줘도 실제로는 그렇지 않을 수도 있다.  
단순히 버전 번호를 잘못 매겨서, 혹은 의존성 네트워크의 어딘가에서 하이럼의 법칙이 작용해서일 수 있다.  
대체로 규모가 커질수록 SemVer의 단점이 드러난다.

## 21.5 자원이 무한할 때의 의존성 관리

지금은 SemVer가 지배하고 있지만, 더 많은 컴퓨팅 자원을 쓸 수 있고 다운스트림 의존성 정보를 더 쉽게 얻을 수 있다면 달라질 것이다.  
이 혁신적인 변화는 업계의 시각이 근본적으로 달라져야 가능하다.
