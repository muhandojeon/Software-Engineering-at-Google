# 의존성 관리

## 의존성 관리가 어려운 이유

- 다이아몬드 의존성 문제
  - 이 문제가 주는 충격은 프로그래밍 언어에 따라 다르다.
    - 어떤 언어에서는 빌드 하나에 의존성이 여러 버전을 모두 포함시킬 수 있다.

> NPM/PNPM/Yarn은 기본적으로 다중 버전 공존을 허용(중첩 node_modules), 번들러가 둘 다 묶을 수 있음.
문제는 “싱글톤/컨텍스트/인스턴스 동일성”을 요구하는 라이브러리에서 발생. 대표적으로 React, styled-components, Zustand/Redux 스토어, React Router, i18next, Emotion 등.
단순 유틸(lodash, date-fns 등)은 보통 동시 공존해도 치명적이지 않지만 번들 사이즈는 커짐.
>
> 그래서 상황에 따라 피어 디펜던시로 구성

- 버전 여러 개를 동시에 내장하는 방식은 함수 수준에서는 이름을 고쳐 동작하게 할 수 있으나 의존성 사이에 주고받는 타입에는 불가능
  - 문제가 되는 의존성을 로컬에 따로 패치하거나 해야함

> npm, pnpm에서는 overrides로
> yarn에서는 resolutions 필드로 사용하는 곳에서 의존성 버전을 고정할 수 있음

## 의존성 임포트하기

- 프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다. 두말하면 잔소리고, 기술이 진보할 수 있는 근본에 속한다. 
  - 만약 프로그래밍 입문자 모두가 자신만의 JSON 파서와 정규 표현식 엔진을 다시 구현해야 한다면 기술은 한 발짝도 앞으로 나아갈 수 없다.

## 임포트 시 고려사항

- 유명하다고 다 좋은 것은 아니지만 반드시 고려해보면 좋음
- 지향하는 호환성 정책
- 앞으로 어떤 분야나 용도를 지원해나갈 것인지 설명중인지
- 얼마나 인기 있는지
- 언제까지 이용할 건지
- 파괴적인 변경이 얼마나 빈번하게 행해지고 있는지

조직 관점
- 구글이 같은 기능을 새로 구현하려면 얼마나 복잡한지
- 의존성을 최신 상태로 유지하면 어떤 이점이 있는지
- 업그레이드는 누가 할 건지
- 업그레이드 난이도

> 조직의 상태에 따라 어떤 것을 만들고 / 어떤 것을 사용할지 갈릴듯 ..
> 구글은 프레임워크뿐 아니라 언어랑 환경도 만드니 뭐 ..

## 이론상의 의존성 관리

- 새로 시작하는 프로젝트가 수십 년을 살아남고, 그래서 의존성을 물 흐르듯 업데이트해야 할 필요가 있을지를 알고 시작하는 경우는 흔치 않다.
  - 그래서 프로젝트의 처음 몇 해는 의존성들이 완벽하게 안정적일 거라 가정하고 진행하는 게 훨씬 합리적일 것이다

## 핵심 정리

- 의존성 관리보다는 되도록 버전 관리가 되도록 한다. 더 많은 코드를 조직 내로 가져와 투명성과 통제력을 높인다면 문제가 훨씬 단순해진다.

> 구글의 써드파티 디렉터리가 기억에 남음
>
> 이전 회사에서는 디렉터리를 하나 파고,
> 의존성이 제공하는 API를 다시 export하는 식으로 햇엇음
> 언제든 자체 개발로 대체하거나, 다른 라이브러리를 사용할 수 잇도록 하게끔이 이유였는데
> 지금 생각해보면 이것 자체도 시멘틱 버저닝이 되어야 햇엇을듯..
