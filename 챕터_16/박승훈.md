## 버전 관리란?

### 버전 관리가 중요한 이유

- '즉각 이루어지는 소스 코드 생산'과 '제품을 장기간 지속 관리'하는 행위를 다른 차원으로 구분한다. VCS의 중요성과 주저하는 마음을 설명하는 큰 기준이다.
- 버전에서 가장 중요한 시간을 명확히 드러내준다. 프로그래밍에서는 필요하지 않지만, 소프트웨어 엔지니어링에서는 아주 중요한 요소이다.
- 경영진이 엔지니어의 일을 '소프트웨어 엔지니어링'이 아닌 '소프트웨어 개발'로만 생각해도 VCS를 주저하게 된다. 그저 코드만 작성하는 일로 바라본다는 뜻이다. 코드를 작성하고 런칭 이후에도 오랜 기간 중단 없이 작동하며 가치를 창출하도록 관리하는 일로 보지 않는 것이다.
- 버전 관리를 이용하면 여러 개발자들이 비슷한 프로세스로 개발할 수 있다. 팀과 조직을 확장할 수 있는 중요한 열쇠이다. 어느 게 최선인지, 어떤 게 변경되었는지 편의성 있게, 자동화해서 정리한다.

> 개발을 처음 접했을 시점에는 git과 branch가 너무 어렵고 이해가 안 됐는데 이제는 없으면 정말 개발 못 할 것 같습니다. 나아가 현재를 위해서가 아니라, 미래를 위해서라도 git을 통한 버전 관리는 필수라고 느낍니다. 혼자 하는 프로젝트에서도 어김 없이요.

### 중앙 집중형 VCS vs 분산형 VCS

#### 중앙 집중형 VCS

- 단 하나의 중앙 repository를 이용하는 모델
- 파일들의 버전 관리 상태와 관련한 작업들은 반드시 중앙 서버에 전달되어야 한다.
- 사용자가 파일을 locking하는 방식은 규모가 조금만 커져도 문제가 발생

#### 분산형 VCS(DVCS)

- 중앙 repository라는 제약이 사라진다.
- 본질상 특정한 하나를 진실 공급원으로 지정하지 않기 때문에 오프라인 작업과 협업에 더 유리하다.
- 중앙 집중형 VCS에서는 '기술'적으로 명확하게 정의된 중앙 repository 제공. DVCS에서는 '정책' 수준에서 정의

### 진실 공급원

- 중앙 집중형 VCS에서는 단일 진실 공급원(SSOT)을 가진다.
- DVCS에서는 변경사항이 주 Repository의 특정 trunk branch를 진실 공급원으로 '정의'한다.

## 브랜치 관리

### 개발 브랜치

- 큰 단위로 한 번에 병합하기보다는 작게 자주 병합하는 게 쉽다.
- 거대한 개발 브랜치 병합에는 문제 원인이라고 예상되는 범위를 좁히기가 어렵다.
- 개발 브랜치에 의존하는 방식은 확장하는 데 한계가 있다.

#### 개발 브랜치에 중독되어 가는 과정

- 브랜치 병합 조율은 본질적으로 확장성이 떨어진다.
- 병합 후 테스트하는 데 드는 노력은 모두 무가치한 오버헤드이다.
- 트렁크 기반 개발이 좋다. 대신 테스트와 CI를 적극 활용하여 모든 빌드와 테스트가 항상 성공하도록 관리한다.
- 엔지니어 개개인이 트렁크와 동기화하고 트렁크에 커밋해야 한다.

> 트렁크 기반 개발이 버전을 어떻게 관리할 수 있을까 궁금했는데, 버전이라는 개념 자체가 없다고 생각하면 그럴 수도 있겠다 싶습니다. 음... 아니면 특정 기간이나 시기를 두고 기간을 잘라서 버저닝을 할 수도 있겠네요.

### 릴리즈 브랜치

- 개발 브랜치와 달리 릴리즈 브랜치는 대체로 무해하다.
- 개발 브랜치와는 생을 마감하는 모습이 다르다. 개발 브랜치는 트렁크에 다시 병합되는데, 릴리즈 브랜치는 홀로 존재하다가 사라진다.
- 최고 수준의 기술 조직은 릴리즈 브랜치가 없다. 하루에 몇 번씩 릴리즈할 수 있다면 수정사항을 적용해 다시 배포하는 게 훨씬 쉽기 때문이다.
- '트렁크 기간 개발' 조직과 '장기간 유지되는 개발 브랜치가 적은' 조직일 수록 기술적 성취가 뛰어나다.

> TBD라는 개념을 처음 들었을 때, 이래도 되나? 싶은 생각이 들 정도였는데 나름 이유가 있는 방법론인 것 같습니다. TBD를 경험해보신 분들의 실제 경험담이나 의견이 궁금하네요.

## 구글의 버전 관리

### 여러 버전을 허용한다면?

- 같은 코드베이스의 다른 프로젝트에서 원본과 포크 버전을 동시에 의존한다면 이해가 어려운 런타임 버그로 이어질 수 있다.
- 같은 대상을 가리키는 전이 의존성들은 반드시 단 하나를 가리켜야 한다.

### 원-버전 규칙

- 개발자가 '이 구성요소는 어떤 버전을 사용해야 하죠?'라고 묻는 상황을 만들지 않아야 한다.
- 의존성을 새로 추가할 때 '선택'할 수 있는 버전을 제한한다.
- '일관성'은 조직을 효율적으로 확장할 때 반드시 필요한 규칙이다.

> 의존성을 새롭게 추가할 때 어떤 버전을 사용해야 하는지 헤매지 않고 명확한 게 좋다고 했는데요, 저는 지금까지 많은 라이브러리들을 사용해오면서 원-버전이 잘 지켜진 환경에서 툴을 사용해왔음을 느꼈습니다. 최근에는 react-notion이라는 라이브러리를 알게 되었는데, 더 많은 기능을 커버하는 react-notion-x라는 라이브러리로 별도로 분화했거든요. react-notion-x를 두 라이브러리가 권고하는데, 포크 버전이 오히려 더 자리를 잡은 케이스가 되겠네요.

### 장수 브랜치는 (웬만하면) 금지

- 개발 브랜치를 되도록 만들지 말고, 만들더라도 아주 짧게 쓰고 없애야 한다.
- '진행 중인 작업을 줄여라'
- 구글의 모노레포에서 작업하는 팀은 약 1,000개 정도인데 반해 장수 개발 브랜치에서 작업하는 팀은 두어 개뿐이다.
- 진행중인 작업은 트렁크에 반영하되 사용자와 개발자가 볼 수 없도록 숨긴다.
- 자동화와 도구들은 트렁크와는 찰떡이지만 개발 브랜치가 생겨나면 잘 대응하기 어렵다.

> 확실히 CI와 테스트, 안정성 있는 코드가 올라간다는 확신과 시스템이 있어야 가능한 방법론이라고 생각합니다.

## 모노레포(단일 레포지토리)

- '원-버전'을 고수하기 쉽다.
- 공식 버전이나 중심 역할을 하는 레포지토리를 찾는 과정이 불필요하다.
- 일관성은 도구를 새로 도입하거나 코드를 최적화할 때 혜택이 조직 전체에 빠르게 전파된다.
- 멀티레포에 비해 개발자 접근 제한, 가시성, 권한 등을 부분별로 가져갈 수는 없겠지만 멀티레포는 끊임없이 사용자화하고 유지보수해야 한다.
- 여러 멀티 레포를 개념적으로 하나로 묶는 가상 모노레포(VMR) 형태도 있다.

## 마치며

- 선택에는 대가가 따른다. 개발자들이 어디로 커밋해야 할지, 혹은 어느 버전을 이용해야 할지를 선택할 수 없어야 한다.
- 원-버전 규칙을 적극 권장한다.
