## 빌드 시스템의 목적

- 모든 빌드 시스템의 목적: 엔지니어의 소스 코드를 기계가 읽을 수 있는 바이너리로 변환하는 것
- 훌륭한 빌드 시스템은 다음 두 가지 중요 속성을 최적화한다.
  - 속도: 개발자가 명령 하나로 빌드를 수행하고 몇 초 안에 결과 바이너리를 얻을 수 있어야 한다.
  - 정확성: 소스 파일과 기타 입력 데이터가 같다면 모든 개발자가 어떤 컴퓨터에서 빌드하더라도 항상 동일한 결과를 내어줘야 한다.
- 테스트 목적으로 머신들이 자동으로 빌드를 수행하기도 한다. (CI)
- 자동 빌드 시스템이 워크플로에 도움을 주는 예
  - 사람의 개입 없이 코드가 자동으로 빌드되고 테스트 된 후 프로덕션에 배포된다.
  - 개발자 변경사항은 자동 테스트되어 코드 리뷰용으로 전달된다.

## 빌드 시스템이 없다면?

- compiler는 의존관계의 순서를 맞추기 힘들고 외부 의존성 대응이 안 된다.
- shell script는 지루하고 느리고 리스크에 대응하기 힘들다.

## 모던 빌드 시스템

### 핵심은 의존성이다

- 여러 종류의 의존성들

  - 작업 사이의 의존성
  - 아티팩트 사이의 의존성
  - 본인 코드베이스에서의 내부 의존성
  - 서드파티가 소유한 코드나 데이터로의 외부 의존성

- 어떤 경우든 빌드 시스템을 구축하는 데는 ‘이걸 하려면 저게 필요해’ 패턴이 반복된다.
- 이런 **의존성을 관리하는 일이 빌드 시스템 구축에서 가장 기본이 되는 작업**이다.

### 태스크 기반 빌드 시스템

- shell script가 좋은 예
- 각 태스크는 어떠한 로직을 수행할 수 있는 일종의 스크립트
- 모던 빌드 시스템은 대부분 shell script 대신 빌드 파일 사용

#### 태스크 기반 빌드 시스템의 어두운 면

- shell script는 병렬로 실행하기 어렵다.
- 증분 빌드를 수행하기 어렵다.
- 스크립트를 유지보수하고 디버깅하기 어렵다.

### 아티팩트 기반 빌드 시스템

- 엔지니어는 시스템에게 '무엇'을 빌드할지 정하고, '어떻게'는 시스템이 알아서 하도록 맡기는 것
- 어떤 도구를 언제 실행할지를 빌드 시스템이 완전히 통제
- 정확성을 보장하면서도 훨씬 효율적으로 실행 가능

> gitlab에서 CI/CD할 때 아티팩트가 나오는 개념을 잘 이해를 못했는데 이번 구문을 보면서 조금은 감을 잡은 것 같아요.

### 분산 빌드

- 단위 작업들을 여러 컴퓨터에 뿌려 빌드한 후 취합해 결과를 만드는 기술
- 원격 캐싱: 가장 단순한 분산 빌드
  - 사용자가 아티팩트를 빌드할 때 빌드 시스템은 원격 캐시에 이미 존재하는지 확인
  - 있으면 다운로드하고 없으면 빌드한 후 캐시에 추가
  - 단, 빌드 시스템이 빌드를 완벽히 재현할 수 있어야 한다. (보장해야 한다.)
- 원격 실행: 분산 빌드의 최종 목표
  - 빌드를 하는 '실제' 작업들을 여러 워커에 나눠 수행하는 기술
  - 각 사용자의 컴퓨터에서 구동되는 빌드 도구가 중앙 빌드 마스터에 요청을 보내는 구조
  - 빌드 환경은 필요한 모든 것을 완벽하게 자기 기술해야 워커들이 사람의 개입없이 동작 가능

> 구글의 엄청난 코드 베이스를 배포하기 앞서 빌드하는 것만으로도 정말 큰 일이었겠다 싶었습니다. 이전부터 느꼈지만, 코드베이스 검색부터 코드베이스 버전 관리, 배포 등 큰 규모는 사소한 단계 하나하나 모두 기술력 덩어리라는 걸 다시 한 번 느낍니다.

### 시간, 규모, 트레이드오프

- 어떤 형태의 빌드 시스템을 이용하느냐에 따라 트레이드오프가 존재한다.
- DIY 스크립트 > 태스크 기반 빌드 시스템 > 셸 스크립트 > 아티팩트 기반 시스템
- 빌드 시스템 교체는 비용이 많이 든다. 새로 시작하는 프로젝트는 되도록 아티팩트 기반 빌드 시스템(ex. Bazel)으로 시작

## 모듈과 의존성 다루기

- 모듈을 어떤 단위로 나누느냐에 따라 성능과 유지보수성이 달라진다.
- 전체 프로젝트를 하나의 모듈로 만들면,
  - 외부 의존성을 추가하는 경우가 아니면 빌드 파일을 건드릴 필요 없다.
  - 하지만 전체 빌드를 매번 하나의 작업으로 수행해야 한다.
- 파일 각각을 모듈로 만들면,
  - 빌드 시스템은 캐시와 분산 빌드를 최대한으로 활용 가능하다.
  - 엔지니어가 소스파일에 다른 파일로의 참조를 하나 추가할 때마다 의존성 목록에 반영이 필요하다.

### 아티팩트와 의존성의 규모

- 아티팩트와 의존성을 정의할 때 모듈을 작게 나누는 게 유리하다. 작은 모듈들이 병렬 빌드와 증분 빌드의 이점을 더 잘 활용한다.
- 외부 의존성의 버전도 명확하게 버전 관리해야 한다. 단순히 ‘최신’ 버전에 의존해서는 재현할 수 없는 빌드의 늪에 빠지기 쉽다.

## 마치며

- 올바른 빌드 시스템을 구축하는 방법을 고민하고 시간을 투자할 가치가 충분하다.
- 때로는 엔지니어의 힘과 유연성을 제한해야 생산성을 높일 수 있다.

> 이번이랑 별개의 이야기이지만, 생각나는 게 하나 있습니다. 한때 추상화를 많이 하고 로직을 많이 숨길수록 선언적인 코드라고 생각한 적이 있었는데, 어느 정도 반복이 되고 코드가 길어지더라도 인터페이스를 더 노출하고 조금 덜 견고한 코드가 도움이 되는 경우가 많음을 점점 느낍니다. 시스템과 유연함 사이에서 정도를 잘 지키는 게 중요한 것 같아요.
