빌드 시스템의 목적?

- 엔지니어들이 작성한 소스 코드를 기계가 읽을 수 있는 바이너리로 변환하는 것
- 훌륭한 빌드 시스템은 속도와 정확성이라는 중요 속성을 최적화 해야합니다.

그럼 빌드 시스템이 없다면 어떤 일이 벌어질까

- 컴파일러만으로는 외부 의존성 (ex, 자바의 jar 파일)을 다룰 수 없다.
- 단순한 몇백줄의 프로젝트라면 모르겠지만, 여러 개발자와 머신이 동원되기 시작한다면 **완벽한 빌드 스크립트**라도 머신사이의 미묘한 차이를 조율해주기 어렵다.
- 결국 제대로된 빌드 시스템이 필요하다

## 모던 빌드 시스템

위에 빌드 시스템이 필요한 이유에서 반복되는 주제는 "외부 의존성 관리가 어렵다"이다.

그렇다면 의존성은?

- 작업 사이의 의존성
- 산출물 사이의 의존성
- 자기 코드 베이스에서의 내부 의존성
- 다른 팀이 소유한 서드 파티 등

빌드 시스템을 구축하려면 "이걸 하려면 저게 필요해"라는 패턴이 반복되며,
이 의존성을 관리하는 것이 빌드 시스템 구축에서 가장 기본이 되는 작업이다.

### 태스크 기반 빌드 시스템

기본 작업 단위 : 태스크
각 태스크는 어떠한 로직을 수행할 수 있는 일종의 스크립트이며, 다른 태스트와의 의존 관계를 명시하여 반드시 먼저 수행되도록 할 수 있다.

대부분의 모던 빌드 시스템은 셸 스크립트 대신 빌드 파일을 이용합니다.

- 서로 다른 파일에 빌드 파일을 둘 수 있고
- 기존 태스크에 의존하는 새로운 태스크들을 쉽게 추가할 수 있기 때문에 (ant 등 빌드 도구가 알아서 처리해줌)
  > 빌드 파일 : 빌드 수행 방법을 기술한 파일

하지만, 결국 엔지니어가 많은 것을 처리해야하는 문제가 있습니다.
주요 문제로는

- 빌드 단계를 병렬로 실행하기 어렵다.
- 증분 빌드를 수행하기 어렵다. <- 이미 실행됬는지 확일할 방법이 없기 때문
- 스크립트의 유지 보수 및 디버깅이 어렵다.

### 아티팩트 기반 빌드 시스템

'엔지니어에게 자신의 태스크를 정의할 수 있게 큰힘을 부여한 것'이 이전 시스템 들의 문제다

-> **엔지니어는** 시스템에게 **무엇을 빌드**할지는 정해줄 수 있지만, **어떻게 빌드할지는** **시스템이** 알아서 하도록 맡기는 것

## 분산 빌드

> 단위 작업을 여러 컴퓨터에 뿌려 빌드한 후 취합해 최정 결과를 만들어주는 기술
> 빌드 단위를 충분히 작게 쪼갤 수 있다면, 아무리 큰 빌드도 원하는 시간내에 끝낼 수 있다.

#### 원격 캐시

- 빌드를 수행하는 시스템은 모두 공통의 원격 캐시 서비스를 참고 (ex, 레디스, 구글 클라우드 스토리지)
- 아티팩트를 빌드할때마다 원격캐시에서 이미 존재하는지 체크

#### 원격 실행

- 빌드를 하는 실제 작업들을 여러 워커에 나눠 수행하는 기술
- 각 사용자의 빌드 도구가 중앙 빌드 마스터에 요청을 보내는 구조
  - 빌드 마스터는 요청받은 빌드를 구성하는 액션을 스케쥴링 <-워커 풀 활용
  - 개별 워커는 마스터가 지정해둔 액션을 사용자가 명시한 입력값으로 수행, 아티팩트를 생성
  - 생성된 아티팩트는 최종 사용자에게 전달 전까지 서로 공유함

## 모듈과 의존성 다루기

모듈 : 빌드 가능한 단위를 지정하는 타깃
모듈을 어느 지점으로 나누냐에 따라 성능과 유지보수성이 달라집니다.

- 하나의 프로젝트를 하나의 작업으로 한다면?
  - 빌드 병렬 실행 불가능, 빌드 된 조각을 캐시 불가능
- 파일 각각을 모듈로 만들면
  - 캐시와 분산 빌드를 최대한으로 이용 가능
  - 파일의 참조를 하나 추가할때마다 의존성 목록에 추가해야되 유지보수가 어려워짐

## 마치며

**때로는 엔지니어의 힘과 유연성을 제한해야 생산성을 높일 수 있다**

구글의 요구 조건을 충족하는 빌드 시스템을 만들기 위해 선택한 방법은, 엔지니어로 부터 빌드 정의의 자유를 뺏는 것이였다.
