# 대규모 변경
* 구글의 경우 LSC(Larget Scale Change)는 거의 항상 자동화 도구를 이용해 생성함
  + LSC로 인해 생성되는 변경들은 대체로 다음과 같이 분류할 수 있음
    - 공통 안티패턴 청소
    - 폐기 대상 API 호출 대체
    - 저수준 인프라 개선사항 활성화
    - 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션

## 누가 대규모 변경을 처리하나?

* 반드시 마이그레이션해야 할 만큼 새로운 시스템이 중요하다면 비용을 조직 차원에서 부담하는 게 맞다.
  + 마이그레이션을 중앙에서 처리하면 개별 팀에 떠넘긴 후 전체를 조율해가며 진행하는 유기적 마이그레이션보다 거의 항상 더 빠르고 저렴하다

## 원자적 변경을 가로막는 요인

* 유령의 묘지
  + 구글의 프로덕션 서비스들을 운영하는 SRE 사이에는 '유령의 묘지 근절'이란 주문이 통용된다.
    - 여기서 유령의 묘지란 너무 오래되어 둔하고 복잡해서 아무도 손대려 하지 않는 시스템들

* 테스트
  + 테스트가 실패한 원인을 추적하는 데 드는 엔지니어의 시간은 이런 추가 테스트들을 수행하는 컴퓨팅 시간보다 훨씬 비싼 자원이다.
  + 그러니 모든 변경은 테스트되어야 한다

* 코드 리뷰
  + 거대한 커밋을 검토하기란 지루하고 번거롭고 오류가 스며들기 쉽다. 특히 수동으로 만든 변경이라면 더욱

## 대규모 변경 인프라

* 제품팀들이 자신들의 제품을 가장 잘 이해하듯, 라이브러리 인프라팀들은 인프라의 미묘한 부분까지 가장 잘 아는 사람들
  + 제품팀 사람들도 이 사실을 인정하고 인프라팀을 신뢰하는 일이 LSC를 조직에 연착륙시키는 중요한 첫 단추

* 언어 지원
  + 어떤 언어를 선택할지는 여러 측면에서 코드 수명과 관련이 깊다.
  + 개발자 생산성에 치중하는 언어일수록 유지보수가 더 어렵다. 필연적인 한계 같지는 않지만 우연히도 현재 모습이 그러하다.

## 대규모 변경 프로세스

* 반려동물과 가축
  + 직접 작업하는 변경 사항들은 반려동물
  + LSC는 자동화로 인해 만들어지니 가축처럼 생각하는게 좋음
    - 전체 무리가 영향받지 않는 선에서는 작은 비용으로 언제든 롤백하거나 거부할 수 있는, 이름 없고 얼굴 없느 커밋으로 취급하는 것

## 핵심 정리

* Tricorder는 누군가 폐기 대상 객체를 사용하는 코드를 새로 작성하면 코드 리뷰 때 알려줘서 변경을 역행하지 않게끔 만들어줌
* LSC에 성공하려면 LSC를 습관처럼 진행해야 한다
  + 꾸준히 조금씩
