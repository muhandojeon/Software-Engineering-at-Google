## 들어가며

- 테스트의 가장 중요한 목적은 물론 버그 예방
- 그다음으로 중요한 목적은 엔지니어의 생산성 개선
- 유지보수하기 쉬워야 한다

## 깨지기 쉬운 테스트 예방하기

### 변하지 않는 테스트로 만들기 위해 노력하자

- 순수 리팩토링: 외부 인터페이스는 놔두고 내부만 리팩토링. 테스트는 변경되지 않아야 한다.
- 새로운 기능 추가: 새 기능을 검증할 테스트를 새로 작성. 기존 테스트들은 변경되지 않아야 한다.
- 버그 수정: 버그 수정과 동시에 바로 그 누락됐던 테스트를 추가해야 한다. 통상적으로 기존 테스트는 변경되지 않아야 한다.
- 행위 변경: 기존 테스트가 변경되어야 한다.

### 공개 API를 이용해 테스트하자

- 테스트도 시스템을 다른 사용자 코드와 똑같은 방식으로 호출하라.
- 테스트가 시스템을 사용자와 똑같은 방식으로 사용하는 것

### 상호 작용이 아니라 상태를 테스트하자

- 우리가 원하는 것은 '결과가 무엇인지'
- 상호작용 테스트는 결과에 도달하기까지 시스템이 '어떻게' 작동하냐를 확인

## 명확한 테스트 작성하기

- 명확한 테스트: 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트
- 불명확한 테스트는 목적을 알아내지 못할 가능성이 크다.

### 완전하고 간결하게 만들자

- 완전한 테스트: 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트
- 간결한 테스트: 코드가 산만하지 않고, 관련 없는 정보는 포함하지 않는 테스트
- 테스트를 더 명확하게 만들 수 있다면 중복도 일부 허용한다.

> 단위테스트의 기술 책에서 테스트 전제와 가정을 한 곳에 응집해두어야 한다는 걸 강조했는데 또 나오네요.

### 메서드가 아니라 행위를 테스트하자

- 행위: 특정 상태에서 특정한 일련의 입력을 받았을 때 시스템이 보장하는 '반응'
- 행위 주도 테스트는 대체로 메서드 중심 테스트보다 명확
  - 자연어에 더 가깝게 읽히기 때문에 힘들이지 않고도 자연스럽게 이해 가능
  - 테스트 각각이 더 좁은 범위를 검사하기 때문에 원인과 결과가 더 분명히 드러남
  - 테스트가 짧고 서술적이어서 이미 검사한 기능이 무엇인지 더 쉽게 확인 가능
- 테스트 구조는 행위가 부각되도록 구성
- 테스트 이름은 검사하는 행위에 어울리게 짓기
- 이름에 'and'가 들어간다면 여러 가지 행위를 하고 있을테니 쪼개기

### 테스트에 논리를 넣지 말자

- 복잡성은 대체로 '논리'라는 형태로 나타난다.
- 테스트 코드에서는 스마트한 로직보다 직설적인 코드를 고집해야 한다.
- 더 서술적이고 의미 있는 테스트를 만들기 위해 약간의 중복은 허용하는 것이 좋다.

> 예시가 진짜 좋았다고 생각합니다. 간단한 문자열 연결조차 문제를 만들다니. 테스트들이 하드코딩으로 문자열을 비교하는 데에는 다 이유가 있었던 것 같습니다.

### 실패 메시지를 명확하게 작성하자

- 잘 작성된 실패 메시지는 테스트의 이름과 거의 동일한 정보를 담고 있어야 한다.
- '원하는 결과', '실제 결과', '건네진 매개변수의 값'

> 실패 메시지도 많은 정보를 담아야 하는군요.

## 테스트와 코드 공유: DRY가 아니라 DAMP

- 테스트 코드에서는 DRY가 주는 혜택이 그리 크지 않다.
- 테스트는 복잡해지면 손해다.
- 테스트는 정확성을 스스로 보장해야 한다.
- DAMP: 서술적이고 의미 있는 문구(Descriptive And Meaningful Phrase)
- 단순하고 명료하다면 테스트에서 다소의 중복은 괜찮다.
- 변수, 공유 메서드, 공유 셋업 쓰지 마라.
- 테스트 인프라는 제품 코드와 비슷하다. 여러 테스트에 관여한다. 독립된 제품처럼 자체 테스트를 갖춰야 한다.
