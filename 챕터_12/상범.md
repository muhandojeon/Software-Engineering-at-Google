# 챕터 12 단위 테스트

테스트 가장 중요한 목적: 버그 예방, 엔지니어의 생산성 개선

경험상 구글은 단위테스트 80%, 그 외 범위가 넓은 테스트를 20% 비중

구글은 '테스트 유지보수성'을 상당히 중시 => 유지보수하기 쉬운 테스트는 '그냥 작동하는 테스트' 를 의미

## 깨지기 쉬운 테스트 예방하기

깨지기 쉬운 테스트: 버그 없고, 검증 대상 코드와 관련없는 변경 때문에 실패하는 테스트를 말함

### 공개 API를 이용해 테스트 하자

내부 구현을 위한 코드가 아닌 공개 API를 호출하자 => 테스트가 시스템을 사용자와 똑같은 방식으로 사용하자 => 더 현실적이고 잘 깨지지 않음! 시스템이 명시한 규약을 따르기 때문에~   
=> 이게 깨진다? 다른 사용자도 문제 겪고 있다라는 신호이다~~

### 상호 작용이 아니라 상태 테스트를 하자

대체로 상호작용 테스트는 상태 테스트보다 깨지기 쉬움

우리가 진짜 원하는 것은 결과가 '무엇'이냐지, 상호작용 테스트처럼 시스템이 '어떻게' 작동하냐를 확인하는건 아님

예를 들어, 특정 API가 호출되었는지 검증한다 했을 때 상호작용 테스트(깨지기 쉬운)와 상태 확인 테스트를 비교해보자

상호작용 테스트 시나리오로는 

```java
@Test
  public void shouldWriteToDatabase() {
  accounts.createUser("foobar");
  verify(database).put("foobar"); // 데이터베이스의 put() 메서드가 호출됐는지 확인
}
```

1. 시스템에 버그가 있어서 레코드가 쓰인 직후 삭제돼도 테스트는 성공할 것이다 (실패해야 되는 상황)
2. 시스템을 리팩터링 해서 같은 기능을 다른 API를 호출해 수행하도록 바꿨다면 이 테스트는 실패한다 (성공해야 되는 상황)

이고 상태 테스트는 

```java
@Test
  public void shouldCreateUsers() {
  accounts.createUser("foobar");
  assertThat(accounts.getUser("foobar”)).isNotNull();
}
```

### 명확한 테스트 작성하기

- 완전하고 간결하게 만들기
  - 완전한: 결과에 도달하기 까지 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 담고있는 테스트
  - 간결한: 코드가 산만하지 않고, 관련 없는 정보는 포함 안하는 테스트

### 메서드가 아닌 행위를 테스트하기

given: 시스템 설정 정의, when: 시스템이 수행할 작업, then: 결과 검증

테스트 각각은 단 하나의 행위만 다뤄야 하며, when, then 블록이 하나씩이면 충분함

### 테스트에 논리 넣지 말자

복잡성은 대체로 논리라는 형태로 나타난대요

비록 기본 url이 여러번 중복되고 할 수 있지만, 더 서술적이고 의미있는 테스트를 얻었다고 생각하면 저렴한 비용이긴 함

```js
// x
assertThat(...).isEqualTo(baseUrl + "/albums");

// o
assertThat(...).isEqualTo("http://photos.google.com//albums");
```


## 테스트와 코드 공유: DRY가 아니라 DAMP!

좋은 테스트는 안정적이고, 대상 시스템의 행위가 변경되면 실패하도록 설계되어 있음.

따라서 테스트 코드에서는 DRY가 주는 혜택이 그리 크지 않음

DRY를 고집하는 대신에 테스트 코드는 DAMP가 되도록 노력해야 된다고 함

DAMP: Descriptive and Meaningful Phrase (서술적이고 의미있는 문구)

DAMP가 DRY를 대체하지는 않고, 보완해주는 개념임

핵심은 테스트에서의 리팩터링은 반복을 줄이는게 아니라 더 서술적이고 의미있게 하는 방향으로 이루어져야 한다는 점이다~~


> 개인적으로 구글의 단위 테스트 작성 관행들에 대한 설명이 이해하기 쉽고 명료해서 좋았음   
