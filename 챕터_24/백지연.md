# CHAPTER 24 지속적 배포

코드의 가치는 서브밋 시점이 아니라 고객이 그 기능을 이용할 때 실현된다.

## 24.1 지속적 배포 이디엄 @ 구글

작은 변경들을 자주 배포할수록 품질이 높아진다. 빠를수록 안전하다.

## 24.2 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기

팀이 작을 때는 변경들이 일정한 속도로 코드베이스에 도달하지만, 팀이 커지면 쉽지 않다.  
구글은 모든 팀이 같은 코드베이스의 헤드에서 개발하는 쪽을 선호한다.  
그래서 CI 테스트, 자동 롤백, 문제를 신속하게 식별해주는 범인 찾기 등의 지원책을 마련했다.

## 24.3 변경을 격리해 평가하자: 기능 플래그로 보호하기

플래그 가드는 플래그를 이용하여 제품의 코드를 기능 단위로 제어하는 기법  
빌드 도구는 기능별 플래그를 확인하여 비활성화된 기능은 해당 빌드에서 제외한다.    
ex. 고객에게 이미 제공 중인 안정된 기능은 개발용과 릴리스용 빌드 모두에 포함시키고, 개발 중인 기능은 개발용에만 포함  
릴리스 후 문제가 생기면 바이너리 릴리스 없이 플래그 값만 동적으로 수정할 수 있다.

## 24.4 기민해지기 위한 분투: 릴리스 열차 갖추기

1. 완벽한 바이너리는 없다 : 프로덕션에 새로운 변경을 릴리스할 때마다 무언가를 결정하고 절충해야 한다. (신기능 출시 vs 버그 픽스)  
2. 릴리스 시한을 지켜라 : 릴리스가 다가오면 완고한 자세로 새로운 기능을 외면해야 한다. 

## 24.5 품질과 사용자에 집중: 사용할 기능만 배포하자

소프트웨어가 지나치게 팽창하면 고객은 모바일 기기의 저장 공간, 내려받는 시간, 데이터 비용을 허비한다.  
개발자는 느려진 빌드, 복잡한 배포, 버그 처리 문제를 마주한다.  
고객이 사용할 기능만 전달하는 동적 배포로 사용자 가치와 기능의 가치를 절충해야 한다.  
동적 배포를 활용하면 각 고객에게 의미 있는 코드만으로 작게 구성한 바이너리를 배포할 수 있다.

## 24.6 원점 회귀: 데이터에 기초해 더 일찍 결정하자

사용자 기반이 충분히 크다면 며칠 혹은 몇 시간이면 충분히 유의미한 결과를 얻을 수 있다.  
여기에 지표를 얻고 판단하는 과정까지 자동화하면, 가드레일 지표(최소한 현재 수준을 유지해야 하는 지표)에 영향이 없다고 판단할 만큼의 데이터가 쌓이는 즉시 더 많은 사용자에게 신버전을 배포할 수 있다.  

사용자 수가 충분하지 않을 때는 중립적인 릴리스를 추천한다.  
새로운 기능을 모두 플래그로 막아두고 배포하면, 배포 과정에서는 유일하게 배포 자체의 안정성만을 검증할 수 있다.

## 24.7 팀 문화 바꾸기: 배포 규율 세우기

'늘 배포하라' 정책은 여러 측면에서 개발자 속도를 높여준다.  
릴리스 열차가 자주 오면 이전의 좋은 상태와의 차이가 적어서 문제가 생겨도 살펴봐야 할 범위가 좁혀진다.  
새로운 기능을 출시하고야 말겠다는 개발자의 열정과 성급함이 고객이 느끼는 경험보다 중요할 수는 없다.  

## 24.8 마치며

더 작게 변경해 자주 배포하는 제품이 품질도 우수하다.  
최종 사용자에게까지 배포하지 않더라도 단순히 지속적 배포를 할 수 있는 구조를 갖추는 것만으로도 엄청난 가치를 창출할 수 있다.

> 제가 속한 크루도 작게 변경해 자주 배포하는 방식으로 일하고 있어요.  
> 3일 이내로 개발 가능한 에픽, 태스크 작업을 계속 진행합니다.

```
ex. 임팩트 3 / 작업 공수 1  → 에픽 작업으로 선정 (우선순위 높음)
ex. 임팩트 3 / 작업 공수 3 → 에픽 작업으로 선정 (우선순위 낮음, 더 효율 좋은 작업이 있다면 해당 작업 진행)
ex. 임팩트 0~1 / 작업 공수 3 → 임팩트 키우거나 작업 공수 절약 방법을 찾아내고, 없으면 드랍
ex. 임팩트 0~1 / 작업 공수 1 → 태스크 작업으로 선정
```
