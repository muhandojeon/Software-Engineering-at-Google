## 들어가며

- 배포는 처음 론칭 때 한 번만 이루어지는 게 아니다.
- 처음부터 완벽한 소프트웨어는 존재하지 않는다.
- 확실한 건 **출시 후 업데이트해야 한다는 사실** 빠르게!
- 소프트웨어 개발에서 가장 큰 위험은 결국은 쓸데없는 무언가를 만들어내는 것
- 고객에게 제품을 보여주지 않은 채 진행하는 기간이 길수록 위험과 비용이 커진다.
- 코드의 가치는 **서브밋 시점이 아니라 고객이 기능을 이용할 때 실현**
- 쾌속 혁신에 중점을 두자.

## 지속적 배포 이디엄 @ 구글

- "빠를수록 안전하다."
- 작은 변경들을 자주 배포할수록 품질이 높아진다.
- 지속적 배포(CD)의 가치
  - 민첩성: 자주, 작게 릴리즈
  - 자동화: 잦은 릴리즈에 수반되는 반복 작업 부담 감소
  - 격리: 변경을 격리, 모듈화된 아키텍처 지향
  - 신뢰성: 비정상 종료와 지연 시간 등의 주요 상태 지표를 측정하고 꾸준히 개선
  - 데이터 중심 의사결정: A/B 테스트
  - 단계적 출시: 변경을 모두에게 동시에 출시하지 않고 소수의 사용자에게 이용해보록 한다.

> 앞서 소개된 A/B 테스트, 카나리 배포 등의 개념도 등장하고, 공감이 되는 여러 요소들도 많네요.

## 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기

- 비용을 줄이고, 규율을 강화하고, 위험에 점진적으로 대응하라.
- 당장의 안정을 위한 프로세스 수정에 저항하고 장기적인 아키텍처 개선에 투자해야 한다.
- 가장 효과가 좋았던 투자는 마이크로서비스 아키텍처로의 전환

## 변경을 격리해 평가자: 기능 플래그로 보호하기

- 지속적인 릴리스를 안정적으로 수행하는 핵심: 엔지니어들이 '모든' 변경에 플래그 가드 넣기
- 비활성화된 플래그와 함께 바이너리 배포를 먼저 하고, 후에 출시 시점에 플래그만 딸깍 바꿔서 기능 활성화
- 특정 기능을 독립적으로 제어할 수 있는 능력은 강력한 도구

## 기민해지기 위한 분투: 릴리스 열차 갖추기

- 자동화할 수 있는 건 자동화, 기능 서브밋 시한 정하기, 플러그인과 데이터를 바이너리에 통합하는 작업을 단순화
- 릴리스 주기를 예측 가능하게 해야 한다.
  - 완벽한 바이너리는 없음을 인정하라.
  - 소프트웨어는 애초에 복잡할 수밖에 없음을 인정하라.
  - 릴리스 시한을 지켜라.
  - 릴리스가 다가오면 완고한 자세로 새로운 기능의 끼워넣기를 외면하라.
  - 릴리스 열차를 놓쳤다면 다음 열차를 타면 된다.

> 릴리스를 자주, 탄력적으로 할 수 있기 때문에 가능한 발상이라고 생각합니다. 확실히 마감일이 정해져있을 때 새로운 기능들이 더 붙는다면 서비스도, 그리고 개발자와 실무자들의 멘탈은 안정적이지 못할 겁니다. 안정성을 위해서는 꼭 필요한 자세라 생각합니다.

## 품질과 사용자에 집중: 사용할 기능만 배포하자

- 크게 성공할수록 더 비대해진다. 가끔 지나치게 팽창하여 제품팀과 사용장게까지 문제를 일으킬 수 있다.
- 고객이 사용할 기능만 전달하는 동적 배포로 사용자 가치와 기능의 가치를 절충하라.
- 모듈화는 동적으로 설정 가능한 배포 전략을 구사할 수 있다.
- A/B 테스트 및 고객이 실제로 사용하는지 판단하는 프로세스를 갖추는 것은 비용이 선제적으로 투입되어야 한다.

## 팀 문화 바꾸기: 배포 규율 세우기

- "늘 배포하라"
- 규모가 커지며 동반하는 복잡성은 릴리스 주기가 길어지는 형태로 나타난다.
- 릴리스 열차가 자주 오면 이전의 '좋은' 상태와의 차이가 적어서 문제 발생시 범인 코드를 좁히기 좋다.
- 릴리스는 개발자로부터 제품을 보호해야 한다.
- 새로운 기능을 출시하고야 말겠다는 개발자의 열정과 성급함이 고객이 느끼는 경험보다 중요할 수는 없다.

## 마치며

- 빠를수록 안전하다.
- 더 작게 변경하고 자주 배포하는 제품이 품질도 우수하다.
- 정기적으로 자주 출발하는 열차는 릴리스 비용을 크게 낮춰 릴리스를 놓치더라도 손해를 입지 않게 한다.
