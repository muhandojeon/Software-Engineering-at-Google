# 챕터8 스타일 가이드와 규칙

- 규칙은 제안이나 권장사항이 아닌, 코드 전반에서 따라야 하는 강제사항
- 지침은 권장사항과 모범 사례, 따르는 편이 이득임. 규칙과 달리 다소 변형해 적용해도 괜춘

구글은 규칙을 모아서 프로그래밍 스타일 가이드를 정리했음. 너무 엄격하지 않은 규칙을 곁들인..

## 규칙이 필요한 이유

'좋은' 행동을 장려하고 '나쁜' 행동을 억제하기 위함

근데 좋고 나쁨은 주관적인건데 어떻게 해석할건데? => 조직마다 추구하는 가치를 파악해야 됨 e.g) 일관성을 최우선으로 한다

확립된 규칙과 지침은 조직이 커지더라도 일관되게 통용되는 공통의 코딩 어휘가 되어줌   
=> 엔지니어들은 코드를 표현하는 '형식'보다 코드에 담을 '내용'에 집중할 수 있게 됨     
=> 공통 어휘를 형성하면 엔지니어들은 무의식적으로 '좋은' 코드를 작성하는 경향이 생김!   


## 규칙 만들기

규칙을 정의할 떄 반드시 던져야 하는 질문은 '무슨 규칙이 필요하지?'가 아니라 '어떤 목표를 이루려 하지?' 이다!    
=> 목표에 집중하면 규칙이 따라온다!

> 항상 비판적인 사고 탑재해야 됨

- 구글의 규칙이 필요한 배경 : 규모와 시간 양쪽 측면에서 탄력적인 엔지니어링 환경이 지속 되도록 하는게 모든 조직에 필요한 가치임
- 구글의 규칙의 목표 : 개발 환경 복잡도 관리하고 엔지니어들의 생산성을 희생하지 않는 선에서 코드베이스를 관리 가능하게끔 유지하는 것

여기서 엔지니어들의 자유를 제한하면서 유연성이 희생되는 트레이드오프가 발생하는데, 일관성을 높여주면서 의견 대립을 줄여주는 방법이 있을까?

### 규칙의 양을 최소화 한다

모든 걸 다 스타일 가이드에 넣을 필요 x, 어차피 규칙 많으면 다 기억 못하고 새로 합류한 엔지니어도 적응하기 어려움. 그리고 그만큼 관리 비용 커짐

그래서 구글은 너무 자명한 규칙은 의도적으로 배제함

### 읽는 사람에게 맞춘다

**코드는 작성되는 횟수보다 읽히는 횟수가 더 많으며 시간이 지날수록 차이가 더 벌어진다 **

구글은 '쓰기에 간편한'보다 '읽기에 간단한' 쪽에 가치를 둠! 

앞으로 그 코드를 읽을 모든 이에게 더 읽기좋은 코드를 선물하기 위해 당장의 불편함을 감내하기로 한 것이다~

> 여기서 함수의 구현부를 들여다보지 않고도 호출 지점에서 무슨 일이 벌어지는지를 명확히 이해할 수 있도록 하는 것이 목적(현 위치에서 추론하기) 라고 했는데 선언적 프로그래밍의 기조와 닮았다~   
> 내가 생각하는 선언적 프로그래밍의 기조: 명령형으로 작성되는 내부 구조를 숨기고, 목적만을 나타내는 코드의 추상화 형태~

### 일관되어야 한다

코드가 일관적이게 작성되어 있으면 익숙지 않은 부분을 살펴볼 일이 생겨도 빠르게 작업 이어가기 가능!

### 일관성이 안겨주는 이점

- 유지보수하기 용이해진다!
- 규모를 확장하기 쉽게 도와준다!
- 프로젝트에 관여할 수 있는 인력이 늘어나고, 일의 효율이 높아진다!

### 표준 정하기

떄로는 외부 커뮤니티에서 정착된 표준도 고려해야 된다~   

일반적으로 규약은 바깥세상과 일관되게 잡는 편이 유리하다~ 왜?   

수명이 길고 확장될 가능성이 큰 코드라면 언젠가는 외부 코드와 상호작용 하고 오픈소스로 확장될 수도 있으니까~~ 

## 오류를 내기 쉽거나 예상과 다르게 동작할 여지가 있는 구조는 피하자

구글의 스타일 가이드는 예상과 다르게 동작할 여지가 있거나 정확한 동작을 예측하기 까다로운 구조는 사용하지 않도록 제한한다~

정확히 이해하지 못한 채 사용하면 그 복잡성 때문에 오용해서 버그를 유발하기 쉽고, 심지어 정확히 이해했다 해도 나중에 합류한 팀원이나 유지보수를 맡은 엔지니어도 같은 수준으로 이해할지는 보장 못하기 때문이다~

예시로, 고급 기능들을 사용하는게 있을텐데(e.g. reflect, proxy?) 전문가에게는 이상적인 해법일 수 있지만 일반적으로는 이해하기 더 어렵고 널리 쓰이지 않는 경우가 대부분이다~

그래서 이해하기 쉽고 유지보수하기 쉬운 명료하고 직관적인 코드를 추구한다!

## 실용적 측면을 인정하자

스타일 가이드의 규칙들에 때로는 예외가 필요하다! 따라서 꼭 필요하다면 최적화나 실용성을 위해 예외를 허용한다

일관성고 가독성을 희생해서라도 성능을 끌여올려야 할 떄가 있다!

**일관성은 매우 중요하지만 융통성이 없어서는 안된다~**

> 매우 중요한 말!

## 언어 스타일 가이드

### 위험 회피하기

어떤 언어 특성은 사용하고 어떤 구조는 피해야 하는지를 설명하는 규칙 담기

### 모범 사례 강제하기

- 작성자의 의도가 코드 자체에 명확하게 드러나지 않는 경우에 의도를 주석으로 남기기
- 콘텐츠가 읽는 사람이 기대하는 순서로 배치되도록 하기 위해 소스 파일의 구조도 규칙으로 상세하기 정의하기
- 패키지, 클래스, 함수, 번수 등의 이름 짓는 규칙

이 규칙들의 목적은 모두 엔지니어가 보다 건실하고 지속가능한 코드를 생산하는 습관을 몸에 익히도록 하는 것이다

### 일관성 구축하기

구글 스타일 가이드에 사소한 문제를 다루는 규칙도 아주 많다. 예를 들어 명명 규칙, 들여쓰기 공백 수, 임포트문 순서 같은 것들

놀라운건 이 범주의 규칙들은 '무엇'을 선택했냐가 아니라 '선택을 했다'라는 사실에 의의가 있다는 것이다!

요런거에 시간을 낭비하지 않는다~

> 로마에 가면 로마법을 따르라 느낌인가..

## 규칙 수정하기

구글의 스타일 가이드는 고정불변이 아니다!

시간이 흐르고 여건이 달라지면 과거에는 옳았던 결정이 현재는 최선이 아니게 될 수 있다

## 규칙 적용하기

규칙을 강제하는 방법으로는 아래 두가지가 있음
- 교육과 훈련을 통한 사회적인 방법 => 코드 리뷰(구글의 가독성 프로세스)
  - 엔지니어들이 규칙을 인지하고 이해하도록 하기 위해 코드리뷰를 자주 함
  - 실제로 가독성 프로세스를 통해 구글 개발 환경을 낯설어하는 엔지니어에게 코드리뷰를 통해 멘토링 해줌으로써 스타일 가이드가 요구하는 습관과 패턴을 체화함
- 도구를 이용한 기술적인 방법 => 자동화 도구 활용
  - 시간이 흐르거나 조직이 커져도 몇몇 규칙이 실수로 누락되거나 잊혀지는 일을 방지할 수 있음
  - 규칙을 미묘하게 다르게 해석하거나 적용하는 일을 최소한으로 줄여줌!
 
변경의 복잡성은 정말 주관적인 영역이다.. 변경 제안이 설정된 최대 라인 수를 초과한다는 이유로 자동 거부하는 도구가 구글에 없는 이유도 그런 이유 떄문이다!  

이런건 리뷰하는 엔지니어들의 재량에 맡긴다. 반대로 기술적 문제를 다루는 규칙은 가능한 기술적으로 자동 집행되기 하는걸 선호한다!

## 오류 검사기

구글은 규칙 준수 검사 도구를 만들었다고 하는데 eslint 같은거겠죠..? 
